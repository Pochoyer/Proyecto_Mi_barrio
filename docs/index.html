<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Red de biciusuarios — Filtro por Sector</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- Turf.js -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    :root{
      --card-bg: #ffffff;
      --card-borde: #2563eb;
      --card-titulo: #1e293b;
      --card-shadow: 0 8px 24px rgba(2,6,23,.08);
      --body-bg: #f3f4f6;
      --acento: #0ea5e9;
      --borde-suave: rgba(2,6,23,.08);
      --radius: 14px;
      --verde: #16a34a;      /* líneas base */
      --verde-hi: #10b981;   /* líneas destacadas */
      --pt-base: #2563eb;    /* puntos base */
      --pt-stroke: #1d4ed8;
      --pt-hi: #0ea5e9;      /* puntos destacados */
      --pt-hi-stroke: #0284c7;
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--body-bg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: #0f172a;
    }

    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px; }

    /* Marco (card) que delimita texto y mapa */
    .card {
      background: var(--card-bg);
      border: 2px solid var(--card-borde);
      border-radius: var(--radius);
      box-shadow: var(--card-shadow);
      overflow: hidden;
    }

    .card__header {
      display: flex; flex-wrap: wrap; align-items: center; justify-content: space-between;
      gap: 12px; padding: 16px 18px; border-bottom: 1px solid var(--borde-suave);
      background:
        radial-gradient(800px 180px at 10% -40%, color-mix(in oklab, var(--acento) 18%, transparent) 0%, transparent 60%),
        radial-gradient(800px 160px at 95% -60%, color-mix(in oklab, var(--card-borde) 20%, transparent) 0%, transparent 65%),
        var(--card-bg);
    }
    .card__title { margin: 0; font-size: clamp(18px, 2.2vw, 24px); font-weight: 700; color: var(--card-titulo); }

    #map { height: 70vh; min-height: 420px; width: 100%; }

    .card__footer { padding: 10px 18px; font-size: 12px; color: #64748b; border-top: 1px solid var(--borde-suave); }

    /* Botón ↺ en la barra Leaflet */
    .leaflet-bar a.custom-reset {
      font-weight: bold; line-height: 26px; width: 28px; height: 28px; text-align: center;
    }

    /* ===== Popup: estilos para datos e imágenes ===== */
    .popup-title { margin: 0 0 6px; font-weight: 800; font-size: 14px; color: #111827; }
    .popup-meta { margin: 0 0 8px; font-size: 12px; color: #6b7280; }
    .popup-grid { display: grid; grid-template-columns: auto 1fr; gap: 4px 8px; font-size: 12px; color: #111827; }
    .popup-grid .k { color: #6b7280; }
    .popup-gallery { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .popup-gallery img {
      max-width: 220px; max-height: 160px; border-radius: 8px; display: block; object-fit: cover;
      box-shadow: 0 2px 8px rgba(0,0,0,.12); border: 1px solid rgba(0,0,0,.06);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="card__header">
        <h1 class="card__title">Red de biciusuarios — entidades que pasan por el sector</h1>
      </div>

      <div id="map"></div>

      <div class="card__footer">
        Tip: dibuja un <em>rectángulo</em> o <em>polígono</em> para filtrar las entidades que interceptan el sector. Usa ↺ para ver todo otra vez.
      </div>
    </div>
  </div>

  <script>
    // ===== 1) Mapa base =====
    const map = L.map('map', { zoomControl: true }).setView([4.65, -74.1], 12); // Bogotá
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // ===== 2) Estilos =====
    const styleLine  = (hi=false) => ({ color: hi ? getComputedStyle(document.documentElement).getPropertyValue('--verde-hi').trim() : getComputedStyle(document.documentElement).getPropertyValue('--verde').trim(), weight: hi ? 4 : 3, opacity: 1 });
    const stylePoint = (hi=false) => ({
      radius: hi ? 7 : 6,
      fillColor: hi ? getComputedStyle(document.documentElement).getPropertyValue('--pt-hi').trim() : getComputedStyle(document.documentElement).getPropertyValue('--pt-base').trim(),
      color: hi ? getComputedStyle(document.documentElement).getPropertyValue('--pt-hi-stroke').trim() : getComputedStyle(document.documentElement).getPropertyValue('--pt-stroke').trim(),
      weight: hi ? 2 : 1, opacity: 1, fillOpacity: hi ? 1 : 0.9
    });

    // ===== 3) Capas =====
    let fuente;      // capa "plantilla" para clonar y filtrar
    let visible;     // capa visible actual
    let drawnItems;  // sector dibujado

    // ===== 4) Popup con imágenes =====
    const IMG_KEYS = ['imagen','imagenes','imagen_url','img','img_url','foto','fotos','photo','photos','image','images','picture','pictures'];
    const esc = s => String(s).replace(/[&<>"'`=\/]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;','=':'&#x3D;','`':'&#x60;'}[c]));

    function extraerImagenes(props){
      const urls = [];
      for (const k of Object.keys(props||{})) {
        if (IMG_KEYS.includes(k.toLowerCase())) {
          const val = props[k];
          if (!val) continue;
          if (Array.isArray(val)) val.forEach(v => pushIfImg(urls, v));
          else String(val).split(',').map(s=>s.trim()).forEach(v => pushIfImg(urls, v));
        }
      }
      return urls;
    }
    function pushIfImg(arr, v){
      const s = String(v||'').trim();
      if (!s) return;
      // acepta http/https, data URI, o rutas relativas/archivos
      if (/^(https?:\/\/|data:image\/|\.{0,2}\/|[^:]+$)/i.test(s)) arr.push(s);
    }

    function tituloFeature(p){
      return p.nombre || p.NOMBRE || p.name || p.titulo || p.title || p.NOMBRE_VIA || p.COD_RUTA || p.codigo || "Detalle";
    }

    function popupHTML(feature){
      const p = feature.properties || {};
      const title = esc(tituloFeature(p));
      const imgs = extraerImagenes(p);

      const omit = new Set(['geometry','coordinates','type', ...IMG_KEYS]);
      const rows = [];
      Object.entries(p).forEach(([k,v])=>{
        if (omit.has(k.toLowerCase?.() || k)) return;
        let val = (typeof v === 'object') ? JSON.stringify(v) : String(v);
        if (val.length > 160) val = val.slice(0,157) + '…';
        rows.push(`<div class="k">${esc(k)}</div><div class="v">${esc(val)}</div>`);
      });

      const gallery = imgs.length
        ? `<div class="popup-gallery">${imgs.map(u => `<a href="${esc(u)}" target="_blank" rel="noopener"><img src="${esc(u)}" alt="imagen"/></a>`).join('')}</div>`
        : '';

      return `<div class="popup">
        <h4 class="popup-title">${title}</h4>
        ${rows.length ? `<div class="popup-grid">${rows.join('')}</div>` : `<p class="popup-meta">Sin atributos adicionales.</p>`}
        ${gallery}
      </div>`;
    }

    function crearCapaDesdeGeoJSON(geojson, hi=false){
      return L.geoJSON(geojson, {
        pointToLayer: (feature, latlng) => {
          const m = L.circleMarker(latlng, stylePoint(hi));
          m.bindPopup(popupHTML(feature));
          return m;
        },
        style: () => styleLine(hi),
        onEachFeature: (feature, layer) => {
          if (feature.geometry && String(feature.geometry.type).includes('Point')) return;
          layer.bindPopup(popupHTML(feature));
        }
      });
    }

    // ===== 5) Dibujo (Leaflet.draw) =====
    drawnItems = new L.FeatureGroup().addTo(map);
    const drawControl = new L.Control.Draw({
      position: "topleft",
      draw: {
        polygon:   { allowIntersection: false, showArea: true, shapeOptions: { color: "#0d9488", weight: 2 } },
        rectangle: { shapeOptions: { color: "#0d9488", weight: 2 } },
        marker: false, circle: false, circlemarker: false, polyline: false
      },
      edit: { featureGroup: drawnItems, edit: true, remove: true }
    });
    map.addControl(drawControl);

    // Botón ↺ (restablecer) junto a las herramientas
    const resetCtrl = L.control({ position: "topleft" });
    resetCtrl.onAdd = function(){
      const div = L.DomUtil.create("div", "leaflet-bar");
      const a = L.DomUtil.create("a", "custom-reset", div);
      a.href = "#"; a.title = "Mostrar todo"; a.innerHTML = "↺";
      L.DomEvent.on(a, "click", (e) => { L.DomEvent.stop(e); restablecer(); });
      return div;
    };
    resetCtrl.addTo(map);

    // ===== 6) Cargar SOLO el GeoJSON suministrado =====
    const GEOJSON_URL = "./data/red-biciusuarios.geojson"; // <-- tu archivo local
    fetch(GEOJSON_URL)
      .then(r => r.json())
      .then(geojson => {
        fuente  = crearCapaDesdeGeoJSON(geojson, false);       // plantilla (no añadida)
        visible = crearCapaDesdeGeoJSON(geojson, false).addTo(map);
        try { map.fitBounds(visible.getBounds(), { padding: [20,20] }); } catch {}
      })
      .catch(err => console.error("Error cargando GeoJSON:", err));

    // ===== 7) Filtrado por sector (Turf) =====
    map.on(L.Draw.Event.CREATED, function (e) {
      drawnItems.clearLayers();
      drawnItems.addLayer(e.layer);
      aplicarFiltro(e.layer);
    });
    map.on(L.Draw.Event.EDITED, function () {
      const capas = drawnItems.getLayers();
      if (capas.length) aplicarFiltro(capas[0]);
    });
    map.on(L.Draw.Event.DELETED, function () { restablecer(); });

    function aplicarFiltro(sectorLayer){
      if (!fuente) return;
      const sector = sectorLayer.toGeoJSON();
      const todas  = fuente.toGeoJSON();

      const filtradas = {
        type: "FeatureCollection",
        features: (todas.features || []).filter(f => {
          try { return turf.booleanIntersects(f, sector); }
          catch { return false; }
        })
      };

      if (visible) { try { map.removeLayer(visible); } catch{} }
      visible = crearCapaDesdeGeoJSON(filtradas, true).addTo(map);

      try { map.fitBounds(visible.getBounds(), { padding: [20,20] }); }
      catch { try { map.fitBounds(sectorLayer.getBounds(), { padding: [20,20] }); } catch{} }
    }

    function restablecer(){
      drawnItems.clearLayers();
      if (!fuente) return;
      if (visible) { try { map.removeLayer(visible); } catch{} }
      const todas = fuente.toGeoJSON();
      visible = crearCapaDesdeGeoJSON(todas, false).addTo(map);
      try { map.fitBounds(visible.getBounds(), { padding: [20,20] }); } catch{}
    }
  </script>
</body>
</html>
